# 系統整合實作

## 前後端架構

### 整體架構圖

```
┌─────────────────────────────────────────┐
│          Frontend (Angular 20)          │
│  ┌──────────┐  ┌──────────┐  ┌────────┐│
│  │ Task UI  │  │ Process  │  │ Report ││
│  │ Module   │  │ Module   │  │ Module ││
│  └──────────┘  └──────────┘  └────────┘│
│         ↓ HTTP/WebSocket ↓              │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      Backend API (Node.js/NestJS)       │
│  ┌──────────────────────────────────┐   │
│  │     Application Services         │   │
│  │  TaskService | ProcessService    │   │
│  └──────────────────────────────────┘   │
│         ↓ Commands/Queries ↓            │
│  ┌──────────────────────────────────┐   │
│  │     Domain Layer (DDD)           │   │
│  │  Aggregates | Domain Services    │   │
│  └──────────────────────────────────┘   │
│         ↓ Events ↓                       │
│  ┌──────────────────────────────────┐   │
│  │     Event Store (Supabase)       │   │
│  │  Events | Projections | Snapshots│   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### Frontend 技術棧

```typescript
// Angular 20 with Signals
@Component({
  selector: 'app-task-list',
  template: `
    <div class="task-list">
      @for (task of tasks(); track task.id) {
        <app-task-card 
          [task]="task"
          (taskUpdated)="handleTaskUpdate($event)"
        />
      }
    </div>
  `
})
export class TaskListComponent {
  // 使用 Signals 管理狀態
  tasks = signal<Task[]>([]);
  loading = signal(false);
  
  constructor(private taskService: TaskService) {
    this.loadTasks();
  }
  
  private loadTasks() {
    this.loading.set(true);
    this.taskService.getTasks().subscribe(tasks => {
      this.tasks.set(tasks);
      this.loading.set(false);
    });
  }
  
  handleTaskUpdate(event: TaskUpdateEvent) {
    // 發送更新到後端
    this.taskService.updateTask(event.taskId, event.updates)
      .subscribe(() => {
        // 重新載入或局部更新
        this.loadTasks();
      });
  }
}
```

### Backend API 設計

```typescript
// NestJS Controller
@Controller('tasks')
export class TaskController {
  constructor(
    private readonly taskCommandService: TaskCommandService,
    private readonly taskQueryService: TaskQueryService
  ) {}
  
  // Command: 建立 Task
  @Post()
  async createTask(@Body() dto: CreateTaskDto): Promise<void> {
    const command = new CreateTaskCommand(
      dto.taskId,
      dto.title,
      dto.workPackageId
    );
    
    await this.taskCommandService.execute(command);
  }
  
  // Query: 查詢 Tasks
  @Get()
  async getTasks(
    @Query() query: GetTasksQuery
  ): Promise<TaskDto[]> {
    return await this.taskQueryService.getTasks(query);
  }
  
  // Command: 完成 Task
  @Post(':id/complete')
  async completeTask(
    @Param('id') taskId: string,
    @Body() dto: CompleteTaskDto
  ): Promise<void> {
    const command = new CompleteTaskCommand(
      taskId,
      dto.completedBy,
      dto.notes
    );
    
    await this.taskCommandService.execute(command);
  }
}
```

## 資料同步策略

### Real-time 更新

**使用 Supabase Realtime:**
```typescript
// Frontend Service
@Injectable()
export class TaskRealtimeService {
  private supabase = createClient(/* ... */);
  
  subscribeToTasks(workPackageId: string): Observable<Task[]> {
    return new Observable(observer => {
      // 訂閱 Supabase Realtime
      const channel = this.supabase
        .channel(`tasks:${workPackageId}`)
        .on(
          'postgres_changes',
          {
            event: '*',
            schema: 'public',
            table: 'task_projections',
            filter: `work_package_id=eq.${workPackageId}`
          },
          (payload) => {
            // 更新本地狀態
            observer.next(this.processPayload(payload));
          }
        )
        .subscribe();
      
      // 清理
      return () => {
        this.supabase.removeChannel(channel);
      };
    });
  }
}
```

### Optimistic Updates

**前端樂觀更新:**
```typescript
// 立即更新 UI,不等待後端回應
async completeTask(taskId: string): Promise<void> {
  // 1. 樂觀更新本地狀態
  this.updateLocalState(taskId, { status: 'Completed' });
  
  try {
    // 2. 發送到後端
    await this.api.completeTask(taskId);
  } catch (error) {
    // 3. 失敗時回滾
    this.revertLocalState(taskId);
    this.showError('操作失敗,請重試');
  }
}
```

### 衝突解決

**Last-Write-Wins (LWW):**
```typescript
// 使用 timestamp 決定優先順序
interface TaskUpdate {
  taskId: string;
  updates: Partial<Task>;
  timestamp: Date;
  userId: string;
}

async handleConflict(
  localUpdate: TaskUpdate,
  remoteUpdate: TaskUpdate
): Promise<TaskUpdate> {
  // 取最新的更新
  if (remoteUpdate.timestamp > localUpdate.timestamp) {
    return remoteUpdate;
  }
  return localUpdate;
}
```

## 離線模式支援

### 離線偵測

```typescript
@Injectable()
export class OfflineService {
  isOnline = signal(navigator.onLine);
  
  constructor() {
    // 監聽網路狀態
    window.addEventListener('online', () => {
      this.isOnline.set(true);
      this.syncPendingChanges();
    });
    
    window.addEventListener('offline', () => {
      this.isOnline.set(false);
    });
  }
  
  private async syncPendingChanges(): Promise<void> {
    // 同步離線時的變更
    const pending = await this.getPendingChanges();
    
    for (const change of pending) {
      try {
        await this.syncChange(change);
        await this.markAsSynced(change.id);
      } catch (error) {
        console.error('同步失敗:', change, error);
      }
    }
  }
}
```

### 本地資料快取

```typescript
// 使用 IndexedDB 儲存離線資料
@Injectable()
export class LocalStorageService {
  private db: IDBDatabase;
  
  async saveTask(task: Task): Promise<void> {
    const tx = this.db.transaction('tasks', 'readwrite');
    const store = tx.objectStore('tasks');
    await store.put(task);
  }
  
  async getTasks(
    workPackageId: string
  ): Promise<Task[]> {
    const tx = this.db.transaction('tasks', 'readonly');
    const store = tx.objectStore('tasks');
    const index = store.index('workPackageId');
    
    return await index.getAll(workPackageId);
  }
}
```

## 效能優化

### 分頁與虛擬滾動

```typescript
// Angular CDK Virtual Scroll
@Component({
  template: `
    <cdk-virtual-scroll-viewport 
      itemSize="80" 
      class="task-list"
    >
      @for (task of tasks(); track task.id) {
        <app-task-card [task]="task" />
      }
    </cdk-virtual-scroll-viewport>
  `
})
export class TaskListComponent {
  // 只載入可見範圍的資料
  tasks = computed(() => {
    const start = this.scrollOffset() / 80;
    const end = start + this.viewportHeight() / 80;
    return this.allTasks().slice(start, end);
  });
}
```

### 懶載入

```typescript
// Angular Route 懶載入
const routes: Routes = [
  {
    path: 'tasks',
    loadComponent: () => 
      import('./task/task-list.component')
        .then(m => m.TaskListComponent)
  },
  {
    path: 'reports',
    loadChildren: () => 
      import('./reports/reports.module')
        .then(m => m.ReportsModule)
  }
];
```

### 快取策略

```typescript
// HTTP 快取
@Injectable()
export class TaskApiService {
  private cache = new Map<string, Observable<Task[]>>();
  
  getTasks(workPackageId: string): Observable<Task[]> {
    // 檢查快取
    if (this.cache.has(workPackageId)) {
      return this.cache.get(workPackageId)!;
    }
    
    // 建立新的請求 (使用 shareReplay 共享)
    const request$ = this.http
      .get<Task[]>(`/api/tasks?wp=${workPackageId}`)
      .pipe(
        shareReplay({ bufferSize: 1, refCount: true })
      );
    
    this.cache.set(workPackageId, request$);
    
    return request$;
  }
  
  // 清除快取
  invalidateCache(workPackageId: string): void {
    this.cache.delete(workPackageId);
  }
}
```

## 監控與維運

### 錯誤追蹤

```typescript
// 整合 Sentry
import * as Sentry from '@sentry/angular';

@Injectable()
export class ErrorHandler implements ErrorHandler {
  handleError(error: Error): void {
    // 記錄到 Sentry
    Sentry.captureException(error);
    
    // 記錄到本地
    console.error('Error:', error);
    
    // 顯示使用者友善訊息
    this.notificationService.showError(
      '發生錯誤,請重試或聯絡支援'
    );
  }
}
```

### 效能監控

```typescript
// 整合 Google Analytics
@Injectable()
export class PerformanceMonitor {
  trackPageLoad(pageName: string): void {
    const loadTime = performance.now();
    
    gtag('event', 'page_load', {
      page_name: pageName,
      load_time: loadTime
    });
  }
  
  trackApiCall(
    endpoint: string, 
    duration: number
  ): void {
    gtag('event', 'api_call', {
      endpoint: endpoint,
      duration: duration
    });
  }
}
```

### 日誌收集

```typescript
// 結構化日誌
@Injectable()
export class LoggerService {
  log(level: string, message: string, context?: any): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level,
      message: message,
      context: context,
      userId: this.authService.getCurrentUserId(),
      sessionId: this.sessionService.getSessionId()
    };
    
    // 發送到後端
    this.http.post('/api/logs', logEntry).subscribe();
    
    // 本地記錄
    console.log(logEntry);
  }
}
```

## 部署策略

### Docker 容器化

```dockerfile
# Frontend Dockerfile
FROM node:22-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### CI/CD Pipeline

```yaml
# GitHub Actions
name: Deploy
on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker Image
        run: docker build -t myapp:latest .
      
      - name: Push to Registry
        run: docker push myregistry.com/myapp:latest
      
      - name: Deploy to Production
        run: kubectl apply -f k8s/deployment.yaml
```

## 總結

系統整合的核心:
1. **前後端分離** - Angular + NestJS
2. **即時同步** - Supabase Realtime
3. **離線支援** - IndexedDB + 同步機制
4. **效能優化** - 虛擬滾動、懶載入、快取
5. **監控維運** - 錯誤追蹤、效能監控、日誌
