# 事件命名與版本策略

## 事件命名規範

### 命名原則

**1. 過去式動詞（Past Tense）**

事件描述「已發生的事實」，必須使用過去式。

```typescript
// ✅ 正確
TaskCreated
OrderPlaced
PaymentCompleted
UserRegistered

// ❌ 錯誤
TaskCreate      // 現在式
CreateTask      // 命令式
TaskCreating    // 進行式
```

**2. 領域語言（Domain Language）**

使用業務人員能理解的術語，避免技術術語。

```typescript
// ✅ 正確
InvoiceIssued           // 發票開立
PaymentReceived         // 收到付款
TaskAssignedToUser      // 任務指派給用戶

// ❌ 錯誤
DatabaseRecordCreated   // 技術術語
ApiCallSucceeded        // 技術細節
StateUpdated            // 太抽象
```

**3. 明確具體（Specific）**

事件名稱應該明確表達發生了什麼，避免模糊術語。

```typescript
// ✅ 正確
TaskCompletedByUser
TaskMarkedAsBlocked
TaskPriorityIncreasedToHigh

// ❌ 錯誤
TaskChanged         // 太模糊
TaskUpdated         // 不知道更新什麼
TaskModified        // 同上
```

**4. 單一職責（Single Responsibility）**

每個事件只描述一個業務事實。

```typescript
// ✅ 正確
TaskAssigned        // 只描述指派
TaskStarted         // 只描述開始

// ❌ 錯誤
TaskAssignedAndStarted      // 包含兩個事實
TaskCreatedWithPriority     // 建立 + 設定優先級
```

### 命名模式

#### Pattern 1: Entity + Action

最常見的模式，適用於大多數業務事件。

```typescript
// 格式：<Entity><Action>
TaskCreated
OrderPlaced
InvoiceIssued
PaymentReceived
```

#### Pattern 2: Entity + Action + Detail

當需要更多細節描述時使用。

```typescript
// 格式：<Entity><Action><Detail>
TaskAssignedToUser
OrderShippedToCustomer
PaymentRefundedToAccount
```

#### Pattern 3: Entity + State + Changed

適用於狀態轉換事件。

```typescript
// 格式：<Entity><State>Changed
TaskStatusChanged
OrderStateChanged
UserRoleChanged
```

#### Pattern 4: Aggregate + SubEntity + Action

適用於聚合根內的子實體操作。

```typescript
// 格式：<Aggregate><SubEntity><Action>
OrderItemAdded
OrderItemRemoved
ContractMilestoneReached
```

### 命名最佳實踐

**1. 避免技術術語**

```typescript
// ✅ 正確
UserRegistered
UserProfileUpdated
UserDeactivated

// ❌ 錯誤
UserRecordInserted
UserTableUpdated
UserFlagSet
```

**2. 避免否定詞**

```typescript
// ✅ 正確
TaskCancelled
OrderRejected
PaymentFailed

// ❌ 錯誤
TaskNotCompleted
OrderNotApproved
PaymentNotSucceeded
```

**3. 明確時間點**

```typescript
// ✅ 正確
TaskStartedAt
OrderPlacedAt
PaymentReceivedAt

// ❌ 錯誤（如果需要明確時間）
TaskStarting
OrderPlacing
PaymentReceiving
```

## 事件版本策略

### 版本演進需求

**為什麼需要版本管理？**

1. **Schema 演進**：業務需求變化導致事件結構調整
2. **向後相容**：舊事件仍需正確重播
3. **長期維護**：系統可能運行多年，歷史事件永久保存

### 版本控制方式

#### 方式 1: 版本號後綴（推薦）

在事件名稱加上版本號。

```typescript
// 版本 1
interface TaskCreatedV1 {
  eventType: 'TaskCreatedV1';
  taskId: string;
  title: string;
  assignedTo: string;
}

// 版本 2：新增 priority 欄位
interface TaskCreatedV2 {
  eventType: 'TaskCreatedV2';
  taskId: string;
  title: string;
  assignedTo: string;
  priority: 'High' | 'Medium' | 'Low';  // 新增
}
```

**優點**：
- 明確版本區分
- 舊版本仍可獨立處理
- 易於測試和除錯

**缺點**：
- 需要維護多個版本的 Handler

#### 方式 2: Event Schema Version

在事件結構內加入版本欄位。

```typescript
interface TaskCreated {
  eventType: 'TaskCreated';
  version: number;              // 版本號
  taskId: string;
  title: string;
  assignedTo: string;
  priority?: string;            // Optional for v1
}
```

**優點**：
- 事件名稱保持一致
- 可以在單一 Handler 處理多版本

**缺點**：
- Handler 邏輯複雜度增加
- 需要謹慎處理 Optional 欄位

#### 方式 3: Upcasting（向上轉換）

將舊版本事件轉換為新版本。

```typescript
// Upcaster
class TaskCreatedUpcaster {
  upcast(event: any): TaskCreatedV2 {
    if (event.eventType === 'TaskCreatedV1') {
      return {
        ...event,
        eventType: 'TaskCreatedV2',
        priority: 'Medium'  // 預設值
      };
    }
    return event;
  }
}

// 在 Event Store 讀取時自動 Upcast
async function getEvents(aggregateId: string): Promise<TaskEvent[]> {
  const rawEvents = await eventStore.get(aggregateId);
  return rawEvents.map(e => upcaster.upcast(e));
}
```

**優點**：
- Handler 只需處理最新版本
- 簡化 Projection 邏輯

**缺點**：
- 需要維護 Upcaster
- 原始事件被轉換，失去歷史真實性

### 版本演進最佳實踐

#### 1. 只增不減（Additive Only）

**✅ 允許的變更**：
- 新增可選欄位（Optional Fields）
- 新增新的事件類型
- 擴展 Enum 值

```typescript
// V1
interface TaskCreated {
  taskId: string;
  title: string;
}

// V2：新增可選欄位
interface TaskCreated {
  taskId: string;
  title: string;
  description?: string;  // ✅ 新增 Optional
  tags?: string[];       // ✅ 新增 Optional
}
```

**❌ 禁止的變更**：
- 刪除欄位
- 修改欄位類型
- 修改欄位名稱
- 修改必填欄位為可選

```typescript
// V1
interface TaskCreated {
  taskId: string;
  title: string;
  assignedTo: string;
}

// V2：❌ 錯誤示範
interface TaskCreated {
  taskId: string;
  // ❌ 刪除 title
  assignedTo: number;     // ❌ 修改類型
  assignee: string;       // ❌ 重命名欄位
}
```

#### 2. 使用語義化版本

```
主版本.次版本
```

**主版本（Major）**：
- 不相容變更（需要新事件名稱）
- 例：TaskCreatedV1 → TaskCreatedV2

**次版本（Minor）**：
- 向後相容的新增功能
- 例：version: 1.0 → 1.1

```typescript
interface TaskCreated {
  eventType: 'TaskCreated';
  version: string;  // "1.0", "1.1", "2.0"
  // ...
}
```

#### 3. 遷移策略

**漸進式遷移**：

```typescript
// Phase 1: 同時支援 V1 和 V2
class TaskProjection {
  apply(event: TaskEvent) {
    if (event.eventType === 'TaskCreatedV1') {
      return this.applyV1(event);
    }
    if (event.eventType === 'TaskCreatedV2') {
      return this.applyV2(event);
    }
  }
}

// Phase 2: 全部 Upcast 到 V2
class TaskProjection {
  apply(event: TaskCreatedV2) {  // 只接受 V2
    // 統一處理
  }
}
```

**批次轉換**（不推薦）：

```typescript
// ❌ 不推薦：修改歷史事件
async function migrateEvents() {
  const events = await eventStore.getAllEvents();
  
  for (const event of events) {
    if (event.eventType === 'TaskCreatedV1') {
      // ❌ 直接修改歷史事件
      event.eventType = 'TaskCreatedV2';
      event.priority = 'Medium';
      await eventStore.update(event);  // ❌ 違反 Immutable
    }
  }
}
```

### 版本管理工具

#### Event Schema Registry

```typescript
interface EventSchema {
  eventType: string;
  version: string;
  schema: any;  // JSON Schema
  upcasters: Upcaster[];
}

class EventSchemaRegistry {
  private schemas = new Map<string, EventSchema[]>();
  
  register(schema: EventSchema) {
    const versions = this.schemas.get(schema.eventType) || [];
    versions.push(schema);
    this.schemas.set(schema.eventType, versions);
  }
  
  getLatestVersion(eventType: string): EventSchema {
    const versions = this.schemas.get(eventType) || [];
    return versions[versions.length - 1];
  }
  
  upcast(event: any): any {
    const currentVersion = event.version || '1.0';
    const latestSchema = this.getLatestVersion(event.eventType);
    
    if (currentVersion === latestSchema.version) {
      return event;
    }
    
    // 逐步 Upcast
    let upcasted = event;
    for (const upcaster of latestSchema.upcasters) {
      upcasted = upcaster.upcast(upcasted);
    }
    
    return upcasted;
  }
}
```

#### Versioning Middleware

```typescript
// Event Store 中間件
class VersioningMiddleware {
  async append(event: DomainEvent): Promise<void> {
    // 自動加上版本資訊
    const schema = schemaRegistry.getLatestVersion(event.eventType);
    const versionedEvent = {
      ...event,
      eventVersion: schema.version,
      eventSchemaVersion: schema.version
    };
    
    await eventStore.append(versionedEvent);
  }
  
  async getEvents(aggregateId: string): Promise<DomainEvent[]> {
    const rawEvents = await eventStore.get(aggregateId);
    
    // 自動 Upcast 到最新版本
    return rawEvents.map(e => schemaRegistry.upcast(e));
  }
}
```

## 事件命名檢查清單

在定義新事件前，檢查以下項目：

- [ ] 使用過去式動詞
- [ ] 使用業務領域語言
- [ ] 名稱明確具體
- [ ] 單一職責（一個事件只描述一件事）
- [ ] 避免技術術語
- [ ] 避免否定詞
- [ ] 符合命名模式（Entity + Action）
- [ ] 與現有事件命名風格一致

## 版本演進檢查清單

在修改事件結構前，檢查以下項目：

- [ ] 是否可以用新增可選欄位解決？
- [ ] 是否需要建立新版本事件？
- [ ] 舊版本事件如何處理？
- [ ] 是否需要 Upcaster？
- [ ] Projection 邏輯是否需要更新？
- [ ] 向後相容性是否保證？
- [ ] 遷移計畫是否清楚？
- [ ] 版本號是否正確遞增？

---

**版本**: 1.0  
**更新日期**: 2024-12-31  
**維護者**: Architecture Team
