# 反模式與禁止事項

## Event Sourcing 反模式

### 1. 直接修改歷史事件

**反模式**：直接更新或刪除已存儲的事件

```typescript
// ❌ 絕對禁止
async function fixWrongEvent(eventId: string) {
  const event = await eventStore.getEvent(eventId);
  event.data.amount = 10000;  // 直接修改
  await eventStore.update(event);  // ❌ 破壞 Immutable
}

// ❌ 絕對禁止
async function deleteEvent(eventId: string) {
  await eventStore.delete(eventId);  // ❌ 破壞完整性
}
```

**正確做法**：使用補償事件

```typescript
// ✅ 正確
async function correctAmount(taskId: string, correctAmount: number) {
  const event = new TaskAmountCorrected({
    taskId: taskId,
    correctAmount: correctAmount,
    reason: '修正錯誤金額',
    causedBy: [originalEventId]
  });
  
  await eventStore.append(event);
}
```

**原因**：
- 破壞事件的不可變性
- 失去審計追蹤能力
- 無法重現問題發生過程

### 2. 在事件中包含業務邏輯

**反模式**：事件帶有執行方法

```typescript
// ❌ 錯誤
interface TaskCompletedEvent {
  taskId: string;
  completedAt: Date;
  
  // ❌ 事件不應該有方法
  execute(): Promise<void>;
  validate(): boolean;
  calculateBonus(): number;
}
```

**正確做法**：事件只是數據

```typescript
// ✅ 正確
interface TaskCompletedEvent {
  eventType: 'TaskCompleted';
  eventId: string;
  taskId: string;
  completedAt: Date;
  completedBy: string;
  causedBy: string[];
  // 只有數據，沒有方法
}
```

**原因**：
- 事件是不可變的數據，不是可執行物件
- 業務邏輯應該在 Decision 或 Domain Service
- 重播事件時不應執行額外邏輯

### 3. 記錄技術細節為事件

**反模式**：將技術操作記錄為 Domain Event

```typescript
// ❌ 錯誤的事件
DatabaseRecordInserted
ApiRequestSent
CacheUpdated
LogWritten
SessionCreated
```

**正確做法**：只記錄業務事實

```typescript
// ✅ 正確的事件
TaskCreated
OrderPlaced
PaymentReceived
UserRegistered
InvoiceIssued
```

**原因**：
- Domain Event 描述業務事實，不是技術操作
- 技術細節應該用日誌（Log）記錄
- 重播事件時不應觸發技術操作

### 4. 事件過於粗粒度

**反模式**：一個事件包含太多資訊

```typescript
// ❌ 過於粗粒度
interface TaskAllDataChanged {
  taskId: string;
  title: string;
  description: string;
  assignedTo: string;
  priority: string;
  status: string;
  tags: string[];
  // 所有欄位都在一個事件
}
```

**正確做法**：事件細粒度、單一職責

```typescript
// ✅ 細粒度事件
TaskTitleChanged
TaskDescriptionUpdated
TaskAssigned
TaskPriorityChanged
TaskStatusChanged
TaskTagAdded
```

**原因**：
- 難以追蹤具體變更
- Projection 邏輯複雜
- 無法精確重播部分變更

### 5. 使用 Event 查詢狀態

**反模式**：每次查詢都重播事件

```typescript
// ❌ 效能問題
async function getTaskStatus(taskId: string): Promise<string> {
  const events = await eventStore.getEvents(taskId);
  const state = replayEvents(events);  // 每次都重播
  return state.status;
}
```

**正確做法**：使用 Read Model

```typescript
// ✅ 使用 Read Model
async function getTaskStatus(taskId: string): Promise<string> {
  const task = await taskReadModel.getById(taskId);
  return task.status;
}

// Read Model 由 Event Handler 維護
class TaskReadModelUpdater {
  async handle(event: TaskEvent) {
    if (event.eventType === 'TaskStatusChanged') {
      await taskReadModel.updateStatus(
        event.taskId, 
        event.newStatus
      );
    }
  }
}
```

**原因**：
- 查詢效能極差
- 系統無法擴展
- 應該使用 CQRS 分離讀寫

## Domain 設計反模式

### 6. Domain 層依賴 Infrastructure

**反模式**：Domain 直接使用 Firebase

```typescript
// ❌ 錯誤
class Task {
  async save() {
    // ❌ Domain 不應該知道 Firebase
    await firebase.firestore()
      .collection('tasks')
      .doc(this.id)
      .set(this.toJSON());
  }
}
```

**正確做法**：透過接口反轉依賴

```typescript
// ✅ 正確
// Core 層定義接口
interface IEventStore {
  append(event: DomainEvent): Promise<void>;
}

// Domain 使用接口
class Task {
  constructor(private eventStore: IEventStore) {}
  
  async complete() {
    const event = new TaskCompletedEvent({ taskId: this.id });
    await this.eventStore.append(event);
  }
}

// Infrastructure 實作接口
class FirebaseEventStore implements IEventStore {
  async append(event: DomainEvent) {
    await firebase.firestore()
      .collection('events')
      .add(event);
  }
}
```

**原因**：
- 違反依賴倒置原則
- Domain 無法獨立測試
- 難以切換 Infrastructure

### 7. 在 Projection 中寫業務邏輯

**反模式**：Projection 包含決策邏輯

```typescript
// ❌ 錯誤
class TaskProjection {
  apply(event: TaskEvent) {
    if (event.type === 'TaskCompleted') {
      // ❌ Projection 不應該判斷業務規則
      if (this.shouldGrantBonus(event)) {
        this.grantBonus(event.userId);
      }
    }
  }
}
```

**正確做法**：Projection 只重建狀態

```typescript
// ✅ 正確
class TaskProjection {
  apply(event: TaskEvent) {
    if (event.type === 'TaskCompleted') {
      // ✅ 只更新狀態
      this.status = 'Completed';
      this.completedAt = event.timestamp;
    }
    
    if (event.type === 'BonusGranted') {
      // ✅ Bonus 由另一個流程產生事件
      this.bonusAmount = event.amount;
    }
  }
}
```

**原因**：
- Projection 應該是 Pure Function
- 業務邏輯屬於 Decision 或 Saga
- 重播事件時不應執行業務邏輯

### 8. Aggregate 過大

**反模式**：單一 Aggregate 包含過多實體

```typescript
// ❌ Aggregate 過大
class Order {
  id: string;
  items: OrderItem[];
  customer: Customer;          // ❌ 不應該包含完整 Customer
  shippingAddress: Address;
  billingAddress: Address;
  payments: Payment[];
  shipments: Shipment[];
  invoices: Invoice[];
  // 太多子實體
}
```

**正確做法**：小而聚焦的 Aggregate

```typescript
// ✅ Order Aggregate 只包含核心
class Order {
  id: string;
  customerId: string;          // ✅ 只保存 ID 引用
  items: OrderItem[];
  totalAmount: number;
  status: OrderStatus;
}

// ✅ Payment 是獨立 Aggregate
class Payment {
  id: string;
  orderId: string;             // ✅ 引用 Order
  amount: number;
  status: PaymentStatus;
}
```

**原因**：
- 併發衝突風險增加
- 事件流過於龐大
- 難以維護和測試

## 架構反模式

### 9. 跨層直接呼叫

**反模式**：UI 直接呼叫 Domain

```typescript
// ❌ 錯誤
class TaskListComponent {
  completeTask(taskId: string) {
    // ❌ UI 不應該直接碰 Domain
    const task = new Task(taskId);
    task.complete();
  }
}
```

**正確做法**：透過 Application Service

```typescript
// ✅ 正確
class TaskListComponent {
  constructor(private taskService: TaskApplicationService) {}
  
  completeTask(taskId: string) {
    // ✅ 透過 Application Service
    this.taskService.completeTask(taskId);
  }
}

// Application Service
class TaskApplicationService {
  async completeTask(taskId: string) {
    // 調用 Policy
    const canComplete = await this.policy.canComplete(taskId);
    if (!canComplete) {
      return Result.err('無權限完成任務');
    }
    
    // 調用 Domain
    const events = await this.eventStore.getEvents(taskId);
    const decision = new CompleteTaskDecision();
    const newEvents = decision.decide({ taskId }, events);
    
    // 儲存事件
    for (const event of newEvents) {
      await this.eventStore.append(event);
    }
    
    return Result.ok();
  }
}
```

**原因**：
- 違反分層架構
- 無法統一處理權限、驗證、審計
- UI 與 Domain 耦合

### 10. Feature 之間直接通訊

**反模式**：Feature 直接 import 其他 Feature

```typescript
// ❌ 錯誤
import { Task } from '../task/domain/task';  // ❌ 跨 Feature

class InvoiceService {
  async createInvoice(taskId: string) {
    const task = await this.taskRepo.getTask(taskId);  // ❌
    // 使用 Task 的內部細節
  }
}
```

**正確做法**：透過 Event 或 Contract

```typescript
// ✅ 正確：透過 Event
class InvoiceService {
  constructor(private eventBus: EventBus) {
    // 訂閱 Task 事件
    this.eventBus.subscribe('TaskCompleted', this.onTaskCompleted);
  }
  
  async onTaskCompleted(event: TaskCompletedEvent) {
    // 根據 Contract（DTO）處理
    await this.createInvoice({
      taskId: event.taskId,
      completedAt: event.completedAt
    });
  }
}
```

**原因**：
- 違反 Bounded Context 原則
- Feature 之間耦合
- 難以獨立演進

## 效能反模式

### 11. 沒有 Snapshot 優化

**反模式**：事件過多時仍全部重播

```typescript
// ❌ 效能問題
async function getTaskState(taskId: string) {
  const events = await eventStore.getEvents(taskId);
  // 10,000 個事件都重播
  return replayAllEvents(events);
}
```

**正確做法**：實作 Snapshot

```typescript
// ✅ 使用 Snapshot
async function getTaskState(taskId: string) {
  const snapshot = await snapshotStore.getLatest(taskId);
  const events = await eventStore.getEventsSince(
    taskId, 
    snapshot.version
  );
  
  // 從快照開始，只重播後續事件
  let state = snapshot.state;
  for (const event of events) {
    state = apply(state, event);
  }
  
  return state;
}
```

**原因**：
- 事件累積後查詢極慢
- 無法擴展到生產環境
- 浪費運算資源

### 12. 同步阻塞處理

**反模式**：事件處理阻塞主流程

```typescript
// ❌ 同步阻塞
async function createTask(cmd: CreateTaskCommand) {
  const event = new TaskCreated(cmd);
  await eventStore.append(event);
  
  // ❌ 阻塞等待所有處理完成
  await sendEmail(event);
  await updateSearchIndex(event);
  await generateNotification(event);
  
  return Result.ok();
}
```

**正確做法**：非同步處理

```typescript
// ✅ 非同步
async function createTask(cmd: CreateTaskCommand) {
  const event = new TaskCreated(cmd);
  await eventStore.append(event);
  
  // ✅ 發布到 Event Bus，非同步處理
  await eventBus.publish(event);
  
  return Result.ok();  // 立即返回
}

// 非同步 Handler
class EmailNotificationHandler {
  async handle(event: TaskCreated) {
    await sendEmail(event);
  }
}
```

**原因**：
- 主流程變慢
- 一個失敗導致全部失敗
- 無法獨立擴展

## 安全反模式

### 13. 在事件中存儲敏感資料

**反模式**：事件包含明文密碼

```typescript
// ❌ 安全問題
interface UserRegisteredEvent {
  userId: string;
  email: string;
  password: string;  // ❌ 明文密碼
  creditCard: string;  // ❌ 信用卡號
}
```

**正確做法**：只存必要資訊

```typescript
// ✅ 安全
interface UserRegisteredEvent {
  userId: string;
  email: string;
  passwordHash: string;  // ✅ Hash 後的密碼
  // ✅ 不存信用卡，另外處理
}
```

**原因**：
- Event Store 永久保存
- 可能被未授權查看
- 違反資料保護法規

## 測試反模式

### 14. 測試依賴真實 Infrastructure

**反模式**：測試直接用 Firebase

```typescript
// ❌ 測試緩慢且不穩定
test('should create task', async () => {
  const eventStore = new FirebaseEventStore();  // ❌ 真實 Firebase
  const service = new TaskService(eventStore);
  
  await service.createTask({ title: 'Test' });
  
  const events = await eventStore.getEvents('task-1');
  expect(events).toHaveLength(1);
});
```

**正確做法**：使用 Mock

```typescript
// ✅ 快速且穩定
test('should create task', async () => {
  const eventStore = new InMemoryEventStore();  // ✅ In-Memory Mock
  const service = new TaskService(eventStore);
  
  await service.createTask({ title: 'Test' });
  
  const events = await eventStore.getEvents('task-1');
  expect(events).toHaveLength(1);
});
```

**原因**：
- 測試執行緩慢
- 依賴外部服務
- 難以自動化

## 禁止事項清單

### 絕對禁止（❌）

- ❌ 修改或刪除歷史事件
- ❌ 在事件中包含方法或業務邏輯
- ❌ Domain 層依賴 Infrastructure
- ❌ UI 層直接呼叫 Domain
- ❌ Feature 之間直接 import
- ❌ 使用 `any` 類型（TypeScript strict mode）
- ❌ 使用 `throw Error`（應該用 Result.Err）
- ❌ 全域變數或單例模式（除非必要）
- ❌ 在事件中存儲敏感資料明文

### 強烈不建議（⚠️）

- ⚠️ 事件過於粗粒度
- ⚠️ Aggregate 過大（> 10 個子實體）
- ⚠️ 沒有 Snapshot（> 1000 事件）
- ⚠️ 同步阻塞處理長時間操作
- ⚠️ 測試依賴真實 Infrastructure
- ⚠️ 缺少錯誤處理和驗證

---

**版本**: 1.0  
**更新日期**: 2024-12-31  
**維護者**: Architecture Team
