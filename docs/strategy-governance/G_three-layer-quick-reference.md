# 三層事件模型 - 快速參考卡

## 一句話記憶法

```
L0 決定「誰能說話」
L1 記錄「世界說了什麼」
L2 解釋「我們怎麼理解它」
```

---

## 快速判斷表

| 問題 | L0 | L1 | L2 |
|------|----|----|-----|
| 這是規則或權限嗎？ | ✅ | ❌ | ❌ |
| 這實際發生了嗎？ | ❌ | ✅ | ❌ |
| 這是計算結果嗎？ | ❌ | ❌ | ✅ |
| 有物理證據嗎？ | ❌ | ✅ | ❌ |
| 可以重新計算嗎？ | ❌ | ❌ | ✅ |
| 可以修改嗎？ | ⚠️ | ❌ | ✅ |
| 能用來請款嗎？ | ❌ | ✅ | ✅ |
| 能算進度嗎？ | ❌ | ✅ | ✅ |

---

## 三秒判斷法

### 判斷 L0
**問：這改變了「誰可以做什麼」嗎？**
- 是 → L0
- 否 → 不是 L0

範例：
- ✅ 簽約 (改變了施工範圍)
- ✅ 授權 (改變了誰能驗收)
- ❌ 澆置 (沒改變規則)

### 判斷 L1
**問三個問題（全是才算）：**
1. 真的發生了？
2. 有證據？
3. 不能假裝沒發生？

範例：
- ✅ 鋼筋綁好了 (有照片)
- ✅ 混凝土澆了 (有送貨單)
- ❌ 預計下週施工 (還沒發生)

### 判斷 L2
**問：這是從 L1 算出來的嗎？**
- 是 → L2
- 否 → 可能是 L1

範例：
- ✅ 完工率 75% (從完成事件算的)
- ✅ 延誤 3 天 (從時間差算的)
- ❌ 澆置完成 (這是事實，是 L1)

---

## 常見錯誤速查

| 錯誤寫法 | 正確寫法 | 層級 |
|---------|---------|------|
| `progress: 75%` | 從完成事件計算 | L1 → L2 |
| `estimated_days: 5` | 不該記錄預測 | ❌ |
| 修改已存在的事件 | 新增修正事件 | L1 |
| 為了報表改事實 | 改計算方法 | L2 |
| 把簽約當進度 | 簽約只是 L0 | L0 |
| 驗收規則當完成 | 實際驗收才算 | L0 → L1 |

---

## TypeScript 最小實作

```typescript
// L0: 治理
interface GovernanceEvent {
  governance_type: 'permission' | 'scope' | 'rule';
  timestamp: Date;
  actor: string;
}

// L1: 事實 (核心!)
interface ConstructionEvent {
  event_type: string;       // 實際做了什麼
  timestamp: Date;          // 何時
  actor: string;            // 誰做的
  target: {                 // 在哪裡
    location?: string;
  };
  evidence: Evidence[];     // 證據 (必填!)
}

// L2: 推導
interface DerivedState {
  completionRate: number;   // 從 L1 算的
  calculatedAt: Date;
  sourceEvents: string[];   // 可追溯
}
```

---

## 依賴方向 (絕對不能錯)

```
✅ 正確方向
L0 → L1 → L2
往下查詢 OK

❌ 禁止方向
L2 → L1  (為了報表改事實)
L1 → L0  (事實改規則)
L2 → L0  (KPI 改規則)
```

---

## 實作優先順序

```
1. L1 (必做) ⭐⭐⭐
   ↓
2. L0 (可以簡化)
   ↓
3. L2 (可以手寫 SQL)
```

**原因：L1 錯了，一切都錯**

---

## 檢查口訣

### L0 檢查
- 沒有物理變化 ✅
- 只定義規則 ✅
- 不能算進度 ✅

### L1 檢查
- 有時間 ✅
- 有人 ✅
- 有證據 ✅
- 不能改 ✅

### L2 檢查
- 從 L1 算 ✅
- 可重算 ✅
- 可追溯 ✅

---

## 緊急救援

### 如果已經做錯了怎麼辦？

#### 狀況 1: L1 包含了推導資訊
```typescript
// ❌ 現在的錯誤結構
interface Event {
  type: string;
  progress: number;  // L2 混進 L1
}

// ✅ 拯救方案
// 1. 停止寫入 progress
// 2. 改用 L2 計算
// 3. 舊資料可以保留,但不再使用
```

#### 狀況 2: L2 被人工填寫了
```typescript
// ❌ 現在的做法
state.completionRate = 80;  // 手動改

// ✅ 拯救方案
// 1. 鎖定 L2 寫入
// 2. 改為從 L1 計算
// 3. 加入計算日誌
```

#### 狀況 3: L1 可以被修改
```typescript
// ❌ 現在的做法
event.location = 'new-location';
update(event);

// ✅ 拯救方案
// 1. 禁用 update()
// 2. 改用補充事件
// 3. 加入 immutability 檢查
```

---

## 最重要的一句話

> **L1 是系統的靈魂**  
> **L1 對了，其他都能修**  
> **L1 錯了，全部重來**

---

## 記憶小抄

```
L0 = Git repo + branch rules
L1 = Git commit (不能改)
L2 = Git log / diff (可重算)

L0 → 誰能說話
L1 → 說了什麼
L2 → 怎麼理解

只能往下 ↓
不能回頭 ↑
```

---

**快速決策樹：**

```
不確定是哪一層？
    ↓
問：有物理證據嗎？
    ↙ 有    ↘ 沒有
   L1        問：定義規則？
              ↙ 是    ↘ 否
             L0       L2
```

---

**緊急聯絡：**

- 有疑問 → 查完整文件
- 要範例 → 看 TypeScript 實作
- 要檢查 → 用檢查清單

**記住：不確定時，問三個問題！**
